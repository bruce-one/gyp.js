'use strict';

const path = require('path');

const gyp = require('../../gyp');

exports.generatorDefaultVariables = {
  'EXECUTABLE_PREFIX': '',
  'EXECUTABLE_SUFFIX': '',
  'STATIC_LIB_PREFIX': 'lib',
  'STATIC_LIB_SUFFIX': '.a',
  'SHARED_LIB_PREFIX': 'lib',

  /* Gyp expects the following variables to be expandable by the build
   * system to the appropriate locations.  Ninja prefers paths to be
   * known at gyp time.  To resolve this, introduce special
   * variables starting with $! and $| (which begin with a $ so gyp knows it
   * should be treated specially, but is otherwise an invalid
   * ninja/shell variable) that are passed to gyp here but expanded
   * before writing out into the target .ninja files; see
   * ExpandSpecial.
   * $! is used for variables that represent a path and that can only appear at
   * the start of a string, while $| is used for variables that can appear
   * anywhere in a string.
   */
  'INTERMEDIATE_DIR': '$!INTERMEDIATE_DIR',
  'SHARED_INTERMEDIATE_DIR': '$!PRODUCT_DIR/gen',
  'PRODUCT_DIR': '$!PRODUCT_DIR',
  'CONFIGURATION_NAME': '$|CONFIGURATION_NAME',

  /* Special variables that may be used by gyp 'rule' targets.
   * We generate definitions for these variables on the fly when processing a
   * rule.
   */
  'RULE_INPUT_ROOT': '${root}',
  'RULE_INPUT_DIRNAME': '${dirname}',
  'RULE_INPUT_PATH': '${source}',
  'RULE_INPUT_EXT': '${ext}',
  'RULE_INPUT_NAME': '${name}'
};

exports.generatorAdditionalNonConfigurationKeys = [];
exports.generatorAdditionalPathSections = [];
exports.generatorExtraSourcesForRules = [];
exports.generatorFilelistPaths = undefined;
exports.generatorSupportsMultipleToolsets = gyp.common.crossCompileRequested();

function stripPrefix(arg, prefix) {
  if (arg.indexOf(prefix) === 0)
    return arg.slice(prefix.lengt);
  return arg;
}

function quoteShellArgument(arg, flavor) {
  /* Quote a string such that it will be interpreted as a single argument
   * by the shell.
   */
  // Rather than attempting to enumerate the bad shell characters, just
  // whitelist common OK ones and quote anything else.
  if (/^[a-zA-Z0-9_=.\\\/-]+$/.test(arg))
    return arg;  // No quoting necessary.
  if (flavor === 'win')
    return gyp.msvs_emulation.quoteForRsp(arg);
  return `'${arg.replace(/'/g, '\'"\'"\'')}'`;
}

function define(d, flavor) {
  /* Takes a preprocessor define and returns a -D parameter that's ninja- and
   * shell-escaped.
   */
  if (flavor === 'win') {
    // cl.exe replaces literal # characters with = in preprocesor definitions for
    // some reason. Octal-encode to work around that.
    d = d.replace(/#/g, '\\%043')
  }
  return quoteShellArgument(gyp.ninjaSyntax.escape(`-D${d}`), flavor);
}

function addArch(output, arch) {
  /* Adds an arch string to an output path. */
  let extension;
  [ output, extension ] = gyp.common.splitext(output);
  return `${output}.${arch}${extension}`;
}

function Target() {
  /* Target represents the paths used within a single gyp target.
   *
   * Conceptually, building a single target A is a series of steps:
   *
   * 1) actions/rules/copies  generates source/resources/etc.
   * 2) compiles              generates .o files
   * 3) link                  generates a binary (library/executable)
   * 4) bundle                merges the above in a mac bundle
   *
   * (Any of these steps can be optional.)
   *
   * From a build ordering perspective, a dependent target B could just
   * depend on the last output of this series of steps.
   *
   * But some dependent commands sometimes need to reach inside the box.
   * For example, when linking B it needs to get the path to the static
   * library generated by A.
   *
   * This object stores those paths.  To keep things simple, member
   * variables only store concrete paths to single files, while methods
   * compute derived values like "the last output of the target".
   */
  // Gyp type ("static_library", etc.) of this target.
  this.type = type;
  // File representing whether any input dependencies necessary for
  // dependent actions have completed.
  this.preactionStamp = undefined;
  // File representing whether any input dependencies necessary for
  // dependent compiles have completed.
  this.precompileStamp = undefined;
  // File representing the completion of actions/rules/copies, if any.
  this.actionsStamp = undefined;
  // Path to the output of the link step, if any.
  this.binary = undefined;
  // Path to the file representing the completion of building the bundle,
  // if any.
  this.bundle = undefined;
  // On Windows, incremental linking requires linking against all the .objs
  // that compose a .lib (rather than the .lib itself). That list is stored
  // here. In this case, we also need to save the compile_deps for the target,
  // so that the the target that directly depends on the .objs can also depend
  // on those.
  this.componentObjs = undefined;
  this.compileDeps = undefined;
  // Windows only. The import .lib is the output of a build step, but
  // because dependents only link against the lib (not both the lib and the
  // dll) we keep track of the import library here.
  this.importLib = undefined;
}

Target.prototype.linkable = function linkable() {
  /* Return true if this is a target that can be linked against. */
  return type === 'static_library' || type === 'shared_library';
};

Target.prototype.usesToc = function usesToc(flavor) {
  /* Return true if the target should produce a restat rule based on a TOC
   * file.
   */
  // For bundles, the .TOC should be produced for the binary, not for
  // FinalOutput(). But the naive approach would put the TOC file into the
  // bundle, so don't do this for bundles for now.
  if (flavor === 'win' || this.bundle)
    return false;

  return this.type === 'shared_library' || this.type === 'loadable_module';
};

Target.prototype.preActionInput = function preActionInput(flavor) {
  /* Return the path, if any, that should be used as a dependency of
   * any dependent action step.
   */
  if (this.usesToc(flavor))
    return this.finalOutput() + '.TOC';
  return this.finalOutput() || this.preactionStamp;
};

Target.prototype.preCompileInput = function preCompileInput() {
  /* Return the path, if any, that should be used as a dependency of
   * any dependent compile step.
   */
  return this.actionsStamp || this.precompileStamp;
};

Target.prototype.finalOutput = function finalOutput() {
  /* Return the last output of the target, which depends on all prior
   * steps.
   */
  return this.bundle || this.binary || this.actionsStamp;
};

/* A small discourse on paths as used within the Ninja build:
 * All files we produce (both at gyp and at build time) appear in the
 * build directory (e.g. out/Debug).
 *
 * Paths within a given .gyp file are always relative to the directory
 * containing the .gyp file.  Call these "gyp paths".  This includes
 * sources as well as the starting directory a given gyp rule/action
 * expects to be run from.  We call the path from the source root to
 * the gyp file the "base directory" within the per-.gyp-file
 * NinjaWriter code.
 *
 * All paths as written into the .ninja files are relative to the build
 * directory.  Call these paths "ninja paths".
 *
 * We translate between these two notions of paths with two helper
 * functions:
 *
 * - GypPathToNinja translates a gyp path (i.e. relative to the .gyp file)
 *   into the equivalent ninja path.
 *
 * - GypPathToUniqueOutput translates a gyp path into a ninja path to write
 *   an output file; the result can be namespaced such that it is unique
 *   to the input file name as well as the output target name.
 */

function NinjaWriter(hashForRules, targetOutputs, baseDir, buildDir,
                     outputFile, toplevelBuild, outputFileName, flavor,
                     toplevelDir) {
  /*
   * base_dir: path from source root to directory containing this gyp file,
   *           by gyp semantics, all input paths are relative to this
   * build_dir: path from source root to build output
   * toplevel_dir: path to the toplevel directory
   */
  this.hashForRules = hashForRules;
  this.targetOutputs = targetOutputs;
  this.baseDir = baseDir;
  this.buildDir = buildDir;
  this.ninja = new gyp.ninjaSyntax.Writer(outputFile);
  this.toplevelBuild = toplevelBuild;
  this.outputFileName = outputFileName;

  this.flavor = flavor;
  this.absBuildDir = undefined;
  // PORT: os.path.abspath
  if (toplevelDir !== undefined)
    this.absBuildDir = path.resolve(path.join(toplevelDir, buildDir));

  this.objExt = flavor === 'win' ? '.obj' : '.o';
  if (flavor === 'win') {
    // See docstring of msvs_emulation.GenerateEnvironmentFiles().
    this.winEnv = {};
    if (arch === 'x86' || arch === 'x64')
      this.winEnv[arch] = 'environment.' + arch;
  }

  // Relative path from build output dir to base dir.
}

function calculateVariables(defaultVariables, params) {
  // XXX(indutny): temporary, just to test input.js
  if (process.platform === 'darwin') {
    if (!defaultVariables['OS'])
      defaultVariables['OS'] = 'mac';
  }
};
exports.calculateVariables = calculateVariables;
