'use strict';

// TODO(indutny): replace with minimal-assert
const assert = require('assert');
const path = require('path');
const crypto = require('crypto');

const gyp = require('../../gyp');

const generatorDefaultVariables = {
  'EXECUTABLE_PREFIX': '',
  'EXECUTABLE_SUFFIX': '',
  'STATIC_LIB_PREFIX': 'lib',
  'STATIC_LIB_SUFFIX': '.a',
  'SHARED_LIB_PREFIX': 'lib',

  /* Gyp expects the following variables to be expandable by the build
   * system to the appropriate locations.  Ninja prefers paths to be
   * known at gyp time.  To resolve this, introduce special
   * variables starting with $! and $| (which begin with a $ so gyp knows it
   * should be treated specially, but is otherwise an invalid
   * ninja/shell variable) that are passed to gyp here but expanded
   * before writing out into the target .ninja files; see
   * ExpandSpecial.
   * $! is used for variables that represent a path and that can only appear at
   * the start of a string, while $| is used for variables that can appear
   * anywhere in a string.
   */
  'INTERMEDIATE_DIR': '$!INTERMEDIATE_DIR',
  'SHARED_INTERMEDIATE_DIR': '$!PRODUCT_DIR/gen',
  'PRODUCT_DIR': '$!PRODUCT_DIR',
  'CONFIGURATION_NAME': '$|CONFIGURATION_NAME',

  /* Special variables that may be used by gyp 'rule' targets.
   * We generate definitions for these variables on the fly when processing a
   * rule.
   */
  'RULE_INPUT_ROOT': '${root}',
  'RULE_INPUT_DIRNAME': '${dirname}',
  'RULE_INPUT_PATH': '${source}',
  'RULE_INPUT_EXT': '${ext}',
  'RULE_INPUT_NAME': '${name}'
};
exports.generatorDefaultVariables = generatorDefaultVariables;

exports.generatorAdditionalNonConfigurationKeys = [];
exports.generatorAdditionalPathSections = [];
exports.generatorExtraSourcesForRules = [];
exports.generatorFilelistPaths = undefined;
exports.generatorSupportsMultipleToolsets = gyp.common.crossCompileRequested();

function stripPrefix(arg, prefix) {
  if (arg.indexOf(prefix) === 0)
    return arg.slice(prefix.lengt);
  return arg;
}

function quoteShellArgument(arg, flavor) {
  /* Quote a string such that it will be interpreted as a single argument
   * by the shell.
   */
  // Rather than attempting to enumerate the bad shell characters, just
  // whitelist common OK ones and quote anything else.
  if (/^[a-zA-Z0-9_=.\\\/-]+$/.test(arg))
    return arg;  // No quoting necessary.
  if (flavor === 'win')
    return gyp.msvs_emulation.quoteForRsp(arg);
  return `'${arg.replace(/'/g, '\'"\'"\'')}'`;
}

function define(d, flavor) {
  /* Takes a preprocessor define and returns a -D parameter that's ninja- and
   * shell-escaped.
   */
  if (flavor === 'win') {
    // cl.exe replaces literal # characters with = in preprocesor definitions for
    // some reason. Octal-encode to work around that.
    d = d.replace(/#/g, '\\%043')
  }
  return quoteShellArgument(gyp.ninjaSyntax.escape(`-D${d}`), flavor);
}

function addArch(output, arch) {
  /* Adds an arch string to an output path. */
  let extension;
  [ output, extension ] = gyp.common.splitext(output);
  return `${output}.${arch}${extension}`;
}

function Target() {
  /* Target represents the paths used within a single gyp target.
   *
   * Conceptually, building a single target A is a series of steps:
   *
   * 1) actions/rules/copies  generates source/resources/etc.
   * 2) compiles              generates .o files
   * 3) link                  generates a binary (library/executable)
   * 4) bundle                merges the above in a mac bundle
   *
   * (Any of these steps can be optional.)
   *
   * From a build ordering perspective, a dependent target B could just
   * depend on the last output of this series of steps.
   *
   * But some dependent commands sometimes need to reach inside the box.
   * For example, when linking B it needs to get the path to the static
   * library generated by A.
   *
   * This object stores those paths.  To keep things simple, member
   * variables only store concrete paths to single files, while methods
   * compute derived values like "the last output of the target".
   */
  // Gyp type ("static_library", etc.) of this target.
  this.type = type;
  // File representing whether any input dependencies necessary for
  // dependent actions have completed.
  this.preactionStamp = undefined;
  // File representing whether any input dependencies necessary for
  // dependent compiles have completed.
  this.precompileStamp = undefined;
  // File representing the completion of actions/rules/copies, if any.
  this.actionsStamp = undefined;
  // Path to the output of the link step, if any.
  this.binary = undefined;
  // Path to the file representing the completion of building the bundle,
  // if any.
  this.bundle = undefined;
  // On Windows, incremental linking requires linking against all the .objs
  // that compose a .lib (rather than the .lib itself). That list is stored
  // here. In this case, we also need to save the compile_deps for the target,
  // so that the the target that directly depends on the .objs can also depend
  // on those.
  this.componentObjs = undefined;
  this.compileDeps = undefined;
  // Windows only. The import .lib is the output of a build step, but
  // because dependents only link against the lib (not both the lib and the
  // dll) we keep track of the import library here.
  this.importLib = undefined;
}

Target.prototype.linkable = function linkable() {
  /* Return true if this is a target that can be linked against. */
  return type === 'static_library' || type === 'shared_library';
};

Target.prototype.usesToc = function usesToc(flavor) {
  /* Return true if the target should produce a restat rule based on a TOC
   * file.
   */
  // For bundles, the .TOC should be produced for the binary, not for
  // FinalOutput(). But the naive approach would put the TOC file into the
  // bundle, so don't do this for bundles for now.
  if (flavor === 'win' || this.bundle)
    return false;

  return this.type === 'shared_library' || this.type === 'loadable_module';
};

Target.prototype.preActionInput = function preActionInput(flavor) {
  /* Return the path, if any, that should be used as a dependency of
   * any dependent action step.
   */
  if (this.usesToc(flavor))
    return this.finalOutput() + '.TOC';
  return this.finalOutput() || this.preactionStamp;
};

Target.prototype.preCompileInput = function preCompileInput() {
  /* Return the path, if any, that should be used as a dependency of
   * any dependent compile step.
   */
  return this.actionsStamp || this.precompileStamp;
};

Target.prototype.finalOutput = function finalOutput() {
  /* Return the last output of the target, which depends on all prior
   * steps.
   */
  return this.bundle || this.binary || this.actionsStamp;
};

/* A small discourse on paths as used within the Ninja build:
 * All files we produce (both at gyp and at build time) appear in the
 * build directory (e.g. out/Debug).
 *
 * Paths within a given .gyp file are always relative to the directory
 * containing the .gyp file.  Call these "gyp paths".  This includes
 * sources as well as the starting directory a given gyp rule/action
 * expects to be run from.  We call the path from the source root to
 * the gyp file the "base directory" within the per-.gyp-file
 * NinjaWriter code.
 *
 * All paths as written into the .ninja files are relative to the build
 * directory.  Call these paths "ninja paths".
 *
 * We translate between these two notions of paths with two helper
 * functions:
 *
 * - GypPathToNinja translates a gyp path (i.e. relative to the .gyp file)
 *   into the equivalent ninja path.
 *
 * - GypPathToUniqueOutput translates a gyp path into a ninja path to write
 *   an output file; the result can be namespaced such that it is unique
 *   to the input file name as well as the output target name.
 */

function NinjaWriter(hashForRules, targetOutputs, baseDir, buildDir,
                     outputFile, toplevelBuild, outputFileName, flavor,
                     toplevelDir) {
  /*
   * base_dir: path from source root to directory containing this gyp file,
   *           by gyp semantics, all input paths are relative to this
   * build_dir: path from source root to build output
   * toplevel_dir: path to the toplevel directory
   */
  this.hashForRules = hashForRules;
  this.targetOutputs = targetOutputs;
  this.baseDir = baseDir;
  this.buildDir = buildDir;
  this.ninja = new gyp.ninjaSyntax.Writer(outputFile);
  this.toplevelBuild = toplevelBuild;
  this.outputFileName = outputFileName;

  this.flavor = flavor;
  this.absBuildDir = undefined;
  // PORT: os.path.abspath
  if (toplevelDir !== undefined)
    this.absBuildDir = path.resolve(path.join(toplevelDir, buildDir));

  this.objExt = flavor === 'win' ? '.obj' : '.o';
  if (flavor === 'win') {
    // See docstring of msvs_emulation.GenerateEnvironmentFiles().
    this.winEnv = {};
    if (arch === 'x86' || arch === 'x64')
      this.winEnv[arch] = 'environment.' + arch;
  }

  // Relative path from build output dir to base dir.
  const buildToTop = gyp.common.invertRelativePath(buildDir, toplevelDir);
  this.buildToBase = path.join(buildToTop, baseDir);
  // Relative path from base dir to build dir.
  const baseToTop = gyp.common.invertRelativePath(baseDir, toplevelDir);
  this.baseToBuild = path.join(baseToTop, buildDir);
}

NinjaWriter.prototype.expandSpecial = function expandSpecial(tpath,
                                                             productDir) {
  /* Expand specials like $!PRODUCT_DIR in |path|.
   *
   * If |product_dir| is None, assumes the cwd is already the product
   * dir.  Otherwise, |product_dir| is the relative path to the product
   * dir.
   */
  const PRODUCT_DIR = '$!PRODUCT_DIR';
  if (tpath.indexOf(PRODUCT_DIR) !== -1) {
    if (productDir) {
      tpath = tpath.replace(PRODUCT_DIR, productDir);
    } else {
      tpath = tpath.replace(PRODUCT_DIR + '/', '');
      tpath = tpath.replace(PRODUCT_DIR + '\\', '');
      tpath = tpath.replace(PRODUCT_DIR, '.');
    }
  }

  const INTERMEDIATE_DIR = '$!INTERMEDIATE_DIR';
  if (tpath.indexOf(INTERMEDIATE_DIR) !== -1) {
    const intDir = this.gypPathToUniqueOutput('gen');
    // GypPathToUniqueOutput generates a path relative to the product dir,
    // so insert product_dir in front if it is provided.
    tpath = tpath.replace(INTERMEDIATE_DIR,
                          path.join(productDir || '', intDir));
  }

  const CONFIGURATION_NAME = '$|CONFIGURATION_NAME';
  tpath = tpath.replace(CONFIGURATION_NAME, this.configName);

  return tpath;
};

NinjaWriter.prototype.expandRuleVaribles =
    function expandRuleVaribles(tpath, root, dirname, source, ext, name) {
  if (this.flavor === 'win') {
    tpath = this.msvsSettings.convertVSMacros(
        tpath, this.confgiName);
  }
  const gdv = generatorDefaultVariables;
  tpath = tpath.replace(gdv['RULE_INPUT_ROOT'], root);
  tpath = tpath.replace(gdv['RULE_INPUT_DIRNAME'], dirname);
  tpath = tpath.replace(gdv['RULE_INPUT_PATH'], source);
  tpath = tpath.replace(gdv['RULE_INPUT_EXT'], ext);
  tpath = tpath.replace(gdv['RULE_INPUT_NAME'], name);
  return tpath;
};

NinjaWriter.prototype.gypPathToNinja = function gypPathToNinja(tpath, env) {
  /* Translate a gyp path to a ninja path, optionally expanding environment
   * variable references in |path| with |env|.
   *
   * See the above discourse on path conversions."""
   */
  if (env) {
    if (this.flavor === 'mac')
      tpath = gyp.xcodeEmulation.expandEnvVars(tpath, env);
    else if (this.flavor === 'win')
      tpath = gyp.msvsEmulation.expandMacros(path, env);
  }
  if (/^\$!/.test(tpath)) {
    let expanded = this.expandSpecial(tpath);
    if (this.flavor === 'win')
      expanded = path.normalize(expanded);
    return expanded;
  }
  if (tpath.indexOf('$|') !== -1)
    tpath = this.expandSpecial(tpath);
  assert(path.indexOf('$') === -1, tpath);
  return path.normalize(path.join(this.buildToBase, tpath));
};

NinjaWriter.prototype.gypPathToUniqueOutput = function gypPathToUniqueOutput(
    tpath, qualified = true) {
  /* Translate a gyp path to a ninja path for writing output.
   *
   * If qualified is True, qualify the resulting filename with the name
   * of the target.  This is necessary when e.g. compiling the same
   * path twice for two separate output targets.
   *
   * See the above discourse on path conversions.
   */

  tpath = this.expandSpecial(tpath);
  assert(tpath[0] !== '$', tpath);

  // Translate the path following this scheme:
  //   Input: foo/bar.gyp, target targ, references baz/out.o
  //   Output: obj/foo/baz/targ.out.o (if qualified)
  //           obj/foo/baz/out.o (otherwise)
  //     (and obj.host instead of obj for cross-compiles)
  //
  // Why this scheme and not some other one?
  // 1) for a given input, you can compute all derived outputs by matching
  //    its path, even if the input is brought via a gyp file with '..'.
  // 2) simple files like libraries and stamps have a simple filename.

  let obj = 'obj';
  if (this.toolset !== 'target')
    obj += '.' + this.toolset;

  const pathDir = path.dirname(tpath);
  let pathBasename = path.basename(tpath);
  assert(!path.isAbsolute(pathDir),
         `'${pathDir} can not be absolute path (see crbug.com/462153).`);

  if (qualified)
    pathBasename = this.name + '.' + pathBasename;
  return path.normalize(path.join(obj, this.baseDir, pathDir, pathBasename));
};

NinjaWriter.prototype.writeCollapsedDependencies =
    function writeCollapsedDependencies(name, targets, orderOnly) {
  /* Given a list of targets, return a path for a single file
   * representing the result of building all the targets or None.
   *
   * Uses a stamp file if necessary.
   */

  assert(targets.filter(t => t).length === targets.length, targets);
  if (targets.length === 0) {
    assert(!orderOnly);
    return;
  }

  if (targets.length > 1 || orderOnly) {
    const stamp = this.gypPathToUniqueOutput(name + '.stamp');
    targets = this.ninja.build(stamp, 'stamp', targets, {
      orderOnly: orderOnly
    });
    this.ninja.newline();
  }
  return targets[0];
};

NinjaWriter.prototype._subninjaNameForArch = function _subninjaNameForArch(
    arch) {
  const outputFileBase = gyp.common.splitext(this.outputFileName)[0];
  return `${outputFileBase}.${arch}.ninja`;
};

NinjaWriter.prototype.writeSpec = function writeSpec(spec, configName,
                                                     generatorFlags) {
  /* The main entry point for NinjaWriter: write the build rules for a spec.
   *
   * Returns a Target object, which represents the output paths for this spec.
   * Returns None if there are no outputs (e.g. a settings-only 'none' type
   * target).
   */

  this.configName = configName;
  this.name = spec['target_name'];
  this.toolset = spec['toolset'];
  const config = spec['configurations'][configName];
  this.target = new Target(spec['type']);
  this.isStandaloneStaticLibrary = !!spec['standalone_static_library'];

  // Track if this target contains any C++ files, to decide if gcc or g++
  // should be used for linking.
  this.usesCpp = false;

  this.targetRpath = generatorFlags['target_rpath'] || '\\$$ORIGIN/lib/';

  this.isMacBundle = gyp.xcodeEmulation.isMacBundle(this.flavor, spec);
  this.xcodeSettings = this.msvsSettings = undefined;
  if (this.flavor === 'mac') {
    this.xcodeSettings = new gyp.xcodeEmulation.XcodeSttings(spec);
    const macToolchainDir = generatorFlags['mac_toolchain_dir'];
    if (macToolChainDir)
      this.xcodeSettings.macToolchainDir = macToolchainDir;
  }

  if (this.flavor === 'win') {
    this.msvsSettings = new gyp.msvsEmulation.MsvsSettings(spec,
                                                           generatorFlags);
    const arch = this.msvsSettings.getArch(configName);
    this.ninja.variable('arch', this.winEnv[arch]);
    this.ninja.variable('cc', `$cl_${arch}`);
    this.ninja.variable('cxx', `$cl_${arch}`);
    this.ninja.variable('cc_host', `$cl_${arch}`);
    this.ninja.variable('cxx_host', `$cl_${arch}`);
    this.ninja.variable('asm', `$ml_${arch}`);
  }

  if (this.flavor === 'mac') {
    this.archs = this.xcodeSettings.getActiveArchs(configName);
    if (this.archs.length > 1) {
      this.archSubninjas = {};
      this.archs.forEach((key) => {
        // TODO(indutny): implement openOutput
        this.archSubninjas[arch] = new gyp.ninjaSyntax.Writer(
          openOutput(path.join(this.toplevelBuild,
                               this._subninjaNameForArch(arch)), 'w'));
      });
    }
  }

  // Compute predepends for all rules.
  // actions_depends is the dependencies this target depends on before running
  // any of its action/rule/copy steps.
  // compile_depends is the dependencies this target depends on before running
  // any of its compile steps.
  let actionsDepends = [];
  let compileDepends = [];
  // TODO(evan): it is rather confusing which things are lists and which
  // are strings.  Fix these.
  if (spec.hasOwnProperty('dependencies')) {
    spec['dependencies'].forEach((dep) => {
      if (this.targetOutputs.hasOwnProperty(dep)) {
        const target = this.targetOutputs[dep];
        actionsDepends.push(target.preActionInput(this.flavor));
        compileDepends.push(target.preCompileInput());
      }
    });

    actionsDepends = actionsDepends.filter(t => t);
    compileDepends = compileDepends.filter(t => t);
    actionsDepends = this.writeCollapsedDependencies('actions_depends',
                                                     actionsDepends);
    compileDepends = this.writeCollapsedDependencies('compile_depends',
                                                     compileDepends);
    this.target.preactionStamp = actionsDepends;
    this.target.precompileStamp = compileDepends;
  }

  // Write out actions, rules, and copies.  These must happen before we
  // compile any sources, so compute a list of predependencies for sources
  // while we do it.
  const extraSources = [];
  const macBundleDepends = [];
  this.target.actionsStamp = this.writeActionsRulesCopies(
      spec, extraSources, actionsDepends, macBundleDepends);

  // If we have actions/rules/copies, we depend directly on those, but
  // otherwise we depend on dependent target's actions/rules/copies etc.
  // We never need to explicitly depend on previous target's link steps,
  // because no compile ever depends on them.
  let compileDependsStamp = this.target.actionsStamp || compileDepends;

  // Write out the compilation steps, if any.
  let linkDeps = [];
  const sources = extraSources.concat(spec['sources'] || []);
  if (sources.length) {
    if (this.flavor === 'mac' && this.archs.length > 1) {
      // Write subninja file containing compile and link commands scoped to
      // a single arch if a fat binary is being built.
      this.archs.forEach((arch) => {
        this.ninja.subninja(this._subninjaNameForArch(arch));
      });
    }

    let pch;
    if (this.flavor === 'win') {
      gyp.msvsEmulation.verifyMissingSources(
          sources, this.absBuildDir, generatorFlags, this.gypPathToNinja);
      pch = gyp.msvsEmulation.precompiledHeader(
          this.msvsSettings, configName, this.gypPathToNinja,
          this.gypPathToUniqueOutput, this.objExt);
    } else {
      pch = gyp.xcodeEmulation.macPrefixHeader(
          this.xcodeSettings, this.gypPathToNinja,
          (path, lang) => this.gypPathToUniqueOutput(path + '-' + lang));
    }
    linkDeps = this.writeSources(
        this.ninja, configName, config, sources, compileDependsStamp, pch,
        spec);
    // Some actions/rules output 'sources' that are already object files.
    const objOutputs = sources.filter((f) => {
      return f.lastIndexOf(this.objExt) === f.length - this.objExt.length;
    });
    if (objOutputs.length) {
      if (this.flavor !== 'mac' || this.archs.length === 1) {
        linkDeps = linkDeps.concat(objOutputs.map(o => this.gypPathToNinja(o)));
      } else {
        console.log(`Warning: Actions/rules writing object files don't work ` +
                    `with multiarch targets, dropping. ` +
                    `(target ${spec['tagret_name']})`);
      }
    }
  } else if (this.flavor === 'mac' && this.archs.length > 1) {
    // PORT: collections.defaultdict(list)
    // TODO(indutny): implement defaultdict
    linkDeps = {};
  }

  const compileDeps = this.target.actionsStamp || actionsDepends;
  if (this.flavor === 'win' && this.target.type === 'static_library') {
    this.target.componentObjs = linkDeps;
    this.target.compileDeps = compileDeps;
  }

  // Write out a link step, if needed.
  let output;
  const isEmptyBundle = linkDeps.length === 0 && macBundleDepends.length === 0;
  if (linkDeps.length !== 0 || this.target.actionsStamp || actionsDepends) {
    output = this.writeTarget(spec, configName, config, linkDeps, compileDeps);
    if (this.isMacBundle)
      macBundleDepends.push(output);
  }

  // Bundle all of the above together, if needed.
  if (this.isMacBundle)
    output = this.writeMacBundle(spec, macBundleDepends, isEmptyBundle);

  if (!output)
    return;

  assert(this.target.finalOutput(), output);
  return this.target;
};

NinjaWriter.prototype._winIdlRule = function _winIdlRule(source, prebuild,
                                                         outputs) {
  /* Handle the implicit VS .idl rule for one source file. Fills |outputs|
   * with files that are generated.
   */
  let [ outdir, output, vars, flags ] = this.msvsSettings.getIdlBuildData(
      source, this.configName);
  outdir = this.gypPathToNinja(outdir);
  function fixPath(tpath, rel) {
    tpath = path.join(outdir, tpath);
    const dirname = path.dirname(source);
    const basename = path.basename(source);
    const [ root, ext ] = gyp.common.splitext(basename);
    tpath = this.expandRuleVariables(
        tpath, root, dirname, source, ext, basename);
    if (rel)
      tpath = path.relative(path, rel);
    return tpath;
  }
  vars = vars.map(([ name, value ]) => [ name, fixPath(value, outdir) ]);
  output = output.map(p => fixPath(p));
  vars.push([ 'outdir', outdir ]);
  vars.push([ 'idlflags', flags ]);
  const input = this.gypPathToNinja(source);
  this.ninja.build(output, 'idl', input, {
    variables: vars,
    orderOnly: prebuild
  });
  output.forEach(e => outputs.push(e));
};

NinjaWriter.prototype.writeWinIdlFiles = function writeWinIdlFiles(spec,
                                                                   prebuild) {
  /* Writes rules to match MSVS's implicit idl handling. */
  assert(this.flavor === 'win');
  if (this.msvsSettings.hasExplicitIdlRulesOrActions(spec))
    return [];
  const outputs = [];
  spec['sources'].filter(x => /\.idl$/.test(x)).forEach((source) => {
    this._winIdlRule(source, prebuild, outputs);
  });
  return outputs;
};

NinjaWriter.prototype.writeActionsRulesCopies =
    function writeActionsRulesCopies(spec, extraSources, prebuild,
                                     macBundleDepends) {
  /* Write out the Actions, Rules, and Copies steps.  Return a path
   * representing the outputs of these steps.
   */
  let outputs = [];
  let macBundleResources;
  if (this.isMacBundle)
    macBundleResources = (spec['mac_bundle_resources'] || []).slice();
  else
    macBundleResources = [];
  const extraMacBundleResources = [];

  if (spec.hasOwnProperty('actions')) {
    outputs = outputs.concat(this.writeActions(spec['actions'], extraSources,
                                               prebuild,
                                               extraMacBundleResources));
  }
  if (spec.hasOwnProperty('rules')) {
    outputs = outputs.concat(this.writeActions(spec['rules'], extraSources,
                                               prebuild,
                                               extraMacBundleResources));
  }
  if (spec.hasOwnProperty('copies')) {
    outputs = outputs.concat(this.writeCopies(spec['copies'], prebuild,
                                              macBundleDepends));
  }
  if (spec.hasOwnProperty('sources'))
    outputs = outputs.concat(this.writeWinIdlFiles(spec, prebuild));

  if (this.xcodeSettings && this.xcodeSettings.isIosFramework())
    this.writeiOSFrameworkHeaderes(spec, outputs, prebuild);

  const stamp = this.writeCollapsedDependencies('actions_rules_copies',
                                                outputs);

  if (this.isMacBundle) {
    const xcassets = this.writeMacBundleResources(
        extraMacBundleResources.concat(macBundleResources), macBundleDepends);
    const partialInfoPlist = this.writeMacXCassets(xcassets, macBundleDepends);
    this.writeMacInfoPlist(partialInfoPlist, macBundleDepends);
  }

  return stamp;
};

NinjaWriter.prototype.generateDescription = function generateDescription(
    verb, message, fallback) {
  /* Generate and return a description of a build step.
   *
   * |verb| is the short summary, e.g. ACTION or RULE.
   * |message| is a hand-written description, or None if not available.
   * |fallback| is the gyp-level name of the step, usable as a fallback.
   */
  if (this.toolset !== 'target')
    verb += `(${target})`;
  if (message)
    return `${verb} ${this.expandSpecial(message)}`;
  else
    return `${verb} ${this.name} ${fallback}`;
};

NinjaWriter.prototype.writeActions = function writeActions(
    actions, extraSources, prebuild, extraMacBundleResources) {
  // Actions cd into the base directory.
  const env = this.getToolchainEnv();
  let allOutputs = [];
  actions.forEach((action) => {
    // First write out a rule for the action.
    const name = `${action['action_name']}_${this.hashForRules}`;
    const description = this.generateDescription('ACTION',
                                                 action['message'],
                                                 name);
    const isCygwin = this.flavor === 'win' &&
                     this.msvsSettings.isRuleRunUnderCygwin(action);
    const args = action['action'];
    let depfile = action['depfile'];
    if (depfile)
      depfile = this.expandSpecial(depfile, this.baseToBuild);
    const pool = action['ninja_use_console'] ? 'console' : undefined;
    const [ ruleName, _ ] = this.writeNewNinjaRule(name, args, description,
                                                   isCygwin, env, pool,
                                                   depfile);

    const inputs = action['inputs'].map(i => this.gypPathToNinja(i, env));
    if (action['process_outputs_as_sources'])
      extraSources = extraSources.concat(action['outputs']);
    if (action['process_outputs_as_mac_bundle_resources']) {
      extraMacBundleResources =
          extraMacBundleResources.concat(action['outputs']);
    }
    const outputs = action['outputs'].map(o => this.gypPathToNinja(o, env));

    // Then write out an edge using the rule.
    this.ninja.build(outputs, ruleName, inputs, { orderOnly: prebuild });
    allOutputs = allOutputs.concat(outputs);

    this.ninja.newline();
  });

  return allOutputs;
};

NinjaWriter.prototype.writeRules = function writeRules(
    rules, extraSources, prebuild, macBundleResources,
    extraMacBundleResources) {
  const env = this.getToolchainEnv();
  let allOutputs = [];
  rules.forEach((rule) => {
    // Skip a rule with no action and no inputs.
    if (!rule.hasOwnProperty('action') &&
        (rule['rule_sources'] || []).length === 0) {
      return;
    }

    // First write out a rule for the rule action.
    const name = `${rule['rule_name']}_${this.hashForRules}`;

    const args = rule['action'];
    const description = this.generateDescription(
        'RULE',
        rule['message'],
        `${name} ${generatorDefaultVariables['RULE_INPUT_PATH']}`);
    const isCygwin = this.flavor === 'win' &&
        this.msvsSettings.isRuleRunUnderCygwin(rule);
    const pool = rule['ninja_use_console'] ? 'console' : undefined;
    let ruleName;
    [ ruleName, args ] = this.writeNewNinjaRules(
        name, args, description, isCygwin, env, pool);

    // TODO: if the command references the outputs directly, we should
    // simplify it to just use $out.

    // Rules can potentially make use of some special variables which
    // must vary per source file.
    // Compute the list of variables we'll need to provide.
    const specialLocals = [ 'source', 'root', 'dirname', 'ext', 'name' ];
    let neededVariables = new Set([ 'source' ]);
    args.forEach((argument) => {
      specialLocals.forEach((v) => {
        if (argument.indexOf(`${v}`) !== -1)
          neededVariables.add(v);
      });
    });
    neededVariables = Array.from(neededVariables);

    function cygwinMunge(tpath) {
      if (isCygwin)
        return tpath.replace(/\\/g, '/');
      return tpath;
    }

    let inputs = (rule['inputs'] || []).forEach((i) => {
      return this.gypPathToNinja(i, env);
    });

    // If there are n source files matching the rule, and m additional rule
    // inputs, then adding 'inputs' to each build edge written below will
    // write m * n inputs. Collapsing reduces this to m + n.
    const sources = rule['rule_sources'] || [];
    let numInputs = inputs.length;
    if (prebuild)
      numInputs++;
    if (numInputs > 2 && sources.length > 2) {
      inputs = [ this.writeCollapsedDependencies(
          rule['rule_name'], inputs, { orderOnly: prebuild }) ];
      prebuild = [];
    }

    // For each source file, write an edge that generates all the outputs.
    sources.forEach((source) => {
      source = path.normalize(source);
      const dirname = path.dirname(source);
      const basename = path.basename(source);
      const [ root, ext ] = gyp.common.splitext(basename);

      // Gather the list of inputs and outputs, expanding $vars if possible.
      let outputs = rule['outputs'].map((o) => {
        return this.expandRuleVariables(o, root, dirname, source, ext,
                                        basename);
      });

      if (rule['process_outputs_as_sources'])
        extraSources = extraSources.concat(outputs);


      const wasMacBundleResource = macBundleResources.indexOf(source) !== -1;
      if (wasMacBundleResource ||
          rule['process_outputs_as_mac_bundle_resources']) {
        extraMacBundleResources = extraMacBundleResources.concat(outputs);
        // Note: This is n_resources * n_outputs_in_rule.  Put to-be-removed
        // items in a set and remove them all in a single pass if this becomes
        // a performance issue.
        if (wasMacBundleResource)
          macBundleResources.splice(macBundleResources.indexOf(source), 1);
      }

      const extraBindings = [];
      neededVariables.forEach((v) => {
        if (v === 'root') {
          extraBindings.push([ 'root', cygwinMunge(root) ]);
        } else if (v === 'dirname') {
          // '$dirname' is a parameter to the rule action, which means
          // it shouldn't be converted to a Ninja path.  But we don't
          // want $!PRODUCT_DIR in there either.
          dirnameExpanded = this.expandSpecial(dirname, this.baseToBuild);
          extraBindings.push([ 'dirname', cygwinMunge(dirnameExpanded) ]);
        } else if (v === 'source') {
          // '$source' is a parameter to the rule action, which means
          // it shouldn't be converted to a Ninja path.  But we don't
          // want $!PRODUCT_DIR in there either.
          const sourceExpanded = this.expandSpecial(source, this.baseToBuild);
          extraBindings.push([ 'source', cygwinMunge(sourceExpanded) ]);
        } else if (v === 'ext') {
          extraBindings.push([ 'ext', ext ]);
        } else if (v === 'name') {
          extraBindings.push([ 'name', cygwinMunge(basename) ]);
        } else {
          assert(false, v);
        }
      });

      outputs = outputs.map(o => this.gypPathToNinja(o, env));
      if (this.flavor === 'win') {
        // WriteNewNinjaRule uses unique_name for creating an rsp file on win.
        extraBindings.push([ 'unique_name',
            crypto.createHash('md5').update(outputs[0]).digest('hex') ]);
      }

      this.ninja.build(outputs, ruleName, this.gypPathToNinja(source), {
        implict: inputs,
        orderOnly: prebuild,
        variables: extraBindings
      });

      outputs.forEach(o => allOutputs.push(o));
    });
  });

  return allOutputs;
};

function calculateVariables(defaultVariables, params) {
  // XXX(indutny): temporary, just to test input.js
  if (process.platform === 'darwin') {
    if (!defaultVariables['OS'])
      defaultVariables['OS'] = 'mac';
  }
};
exports.calculateVariables = calculateVariables;
